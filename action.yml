name: 'Checkout from AWS Mirror'
description: 'Checkout repository from internal AWS git mirror with support for retries and fetch-depth'
inputs:
  git_mirror_hostname:
    description: 'Hostname of the git server mirror'
    required: true
  private_ssh_key:
    description: 'SSH private key for the git server mirror'
    required: true
  git_mirror_user:
    description: 'User for the git server mirror'
    required: true
  git_mirror_repo_path:
    description: 'Path to the git repository on the git server mirror'
    required: true
  fetch-depth:
    description: 'Number of commits to fetch. 0 indicates all history for all branches and tags.'
    required: false
    default: '1'
  submodules:
    description: 'Whether to checkout submodules: true or false'
    required: false
    default: 'true'

runs:
  using: "composite"
  steps:
    - name: Get Hermes
      shell: bash
      run: |
        REGION=$(curl -s http://169.254.169.254/latest/dynamic/instance-identity/document | jq -r '.region')
        AZ=$(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone)
        echo "AWS_REGION=${REGION}" >> $GITHUB_ENV
        echo "AWS_AZ=${AZ}" >> $GITHUB_ENV
        GIT_MIRROR_HOSTNAME_WITH_AZ=$(echo ${{ inputs.git_mirror_hostname }} | sed "s/\./-${AZ}./")
        echo "GIT_MIRROR_HOSTNAME_WITH_AZ=${GIT_MIRROR_HOSTNAME_WITH_AZ}" >> $GITHUB_ENV

    - name: Install SSH key
      uses: webfactory/ssh-agent@v0.9.1
      with:
        ssh-private-key: ${{ inputs.private_ssh_key }}

    - name: Add mirror host to known hosts
      shell: bash
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ env.GIT_MIRROR_HOSTNAME_WITH_AZ }} >> ~/.ssh/known_hosts

    - name: Ensure mirror is up-to-date
      shell: bash
      run: ssh ${{ inputs.git_mirror_user }}@${{ env.GIT_MIRROR_HOSTNAME_WITH_AZ }} /home/git/refresh_hermes.sh

    - name: Checkout repository from EC2 mirror
      shell: bash
      run: |
        set -e
        
        # 1. WORKSPACE SANITIZATION
        if [ -d "$GITHUB_WORKSPACE/.git" ]; then
          echo "Found existing workspace. Cleaning up stale locks and artifacts..."
          # Remove index locks from main repo and all submodules
          find "$GITHUB_WORKSPACE/.git" -name "index.lock" -delete 2>/dev/null || true
          
          cd "$GITHUB_WORKSPACE"
          # Check if the git repo is actually valid
          if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            echo "Resetting repository to clean state..."
            git reset --hard HEAD || true
            git clean -ffdx || true
          else
            echo "Repository state is corrupted. Wiping and starting fresh..."
            cd ..
            rm -rf "$GITHUB_WORKSPACE"
            mkdir -p "$GITHUB_WORKSPACE"
          fi
        fi

        # 2. CONFIGURATION
        MIRROR_URL="ssh://${{ inputs.git_mirror_user }}@${{ env.GIT_MIRROR_HOSTNAME_WITH_AZ }}${{ inputs.git_mirror_repo_path }}"
        FETCH_DEPTH="${{ inputs.fetch-depth }}"
        SUBMODULES="${{ inputs.submodules }}"
        
        RECURSE_FLAG=""
        if [ "$SUBMODULES" = "true" ]; then
          RECURSE_FLAG="--recurse-submodules"
        fi

        if [ "$FETCH_DEPTH" -eq "0" ]; then
          CLONE_ARGS="$RECURSE_FLAG"
        else
          CLONE_ARGS="$RECURSE_FLAG --depth $FETCH_DEPTH"
        fi

        # 3. PREPARE WORKSPACE / CLONE
        if [ -d "$GITHUB_WORKSPACE/.git" ]; then
          echo "Existing git repository found; fetching changes"
          cd "$GITHUB_WORKSPACE"
          git remote remove origin 2>/dev/null || true
          git remote add origin "$MIRROR_URL"
          
          if [ "$FETCH_DEPTH" -eq "0" ]; then
             git fetch --unshallow origin 2>/dev/null || git fetch origin
          else
             if ! git fetch "$MIRROR_URL"; then
               echo "Fetch failed; reverting to clean clone"
               cd ..
               rm -rf "$GITHUB_WORKSPACE"
               mkdir -p "$GITHUB_WORKSPACE"
               cd "$GITHUB_WORKSPACE"
               git clone $CLONE_ARGS "$MIRROR_URL" .
             fi
          fi
        else
          echo "No existing git repository found; cloning with args: $CLONE_ARGS"
          mkdir -p "$GITHUB_WORKSPACE"
          cd "$GITHUB_WORKSPACE"
          git clone $CLONE_ARGS "$MIRROR_URL" .
        fi
        
        cd "$GITHUB_WORKSPACE"
        
        # 4. TARGET SELECTION
        if [[ "${{ github.event_name }}" == "pull_request" || \
              "${{ github.event_name }}" == "pull_request_target" ]]; then
            TARGET_SHA="${{ github.event.pull_request.head.sha }}"
        else
            TARGET_SHA="${{ github.sha }}"
        fi

        # 5. RETRY LOGIC FOR MIRROR SYNC
        commit_exists() {
          git fetch --quiet origin "$1" && return 0
          return 1
        }
        
        MAX_RETRIES=3
        RETRY_DELAY=10
        ATTEMPT=0
        
        while ! commit_exists "$TARGET_SHA" && [ $ATTEMPT -lt $MAX_RETRIES ]; do
          echo "Commit $TARGET_SHA not found in mirror. Refreshing (try $((ATTEMPT+1))/$MAX_RETRIES)..."
          ssh "${{ inputs.git_mirror_user }}@${{ env.GIT_MIRROR_HOSTNAME_WITH_AZ }}" /home/git/refresh_hermes.sh
          sleep $RETRY_DELAY
          ATTEMPT=$((ATTEMPT+1))
          git fetch origin
        done
        
        if ! commit_exists "$TARGET_SHA"; then
          echo "ERROR: Commit $TARGET_SHA is still missing after $MAX_RETRIES attempts."
          exit 1
        fi
        
        # 6. FINAL CHECKOUT
        echo "Commit found! Proceeding with checkout."
        if [ "$FETCH_DEPTH" -eq "0" ]; then
            git fetch --tags origin # Fetch tags specifically for your v1.8.0/v1 logic
            git checkout "$TARGET_SHA"
        else
            git fetch origin "$TARGET_SHA"
            git checkout "$TARGET_SHA"
        fi

        # 7. SUBMODULE UPDATE
        if [ "$SUBMODULES" = "true" ]; then
          echo "Updating submodules..."
          git submodule update --init --recursive
        fi
